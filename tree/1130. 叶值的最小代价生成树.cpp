/*
给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：

每个节点都有 0 个或是 2 个子节点。
数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）
每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。
在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

 

示例：

输入：arr = [6,2,4]
输出：32
解释：
有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。

    24            24
   /  \          /  \
  12   4        6    8
 /  \               / \
6    2             2   4
 

提示：

2 <= arr.length <= 40
1 <= arr[i] <= 15
答案保证是一个 32 位带符号整数，即小于 2^31。

*/

//best 单调栈
/*
但是这道题目有更简单的解法。
下面简述一下来自于 lee215 的思路，
时间复杂度为 O(N)。
这道题可以看做如下过程：在数组 arr 中，每次取相邻的两个数 a 和 b，
然后去掉其中较小的一个，花费代价为 a * b，
求最终将数组消减为一个元素的最小代价。
那么，要想获得最小代价，我们应该采取的策略是：
对于数组中的某一个数 a，
分别向左和向右查询比它大的第一个数，
在这两个数中选择较小的那个数把它消去，花费的代价最小。
这个过程我们可以用单调栈来一次遍历解决掉。

********************************************************

单调栈的方法有点讨巧。
以上是我的个人理解
我们维护一个单调递减栈，单调递减栈有一个特性。
如果我们遇到一个比栈顶元素大元素，于是乎就有了两种情况。
我们就看前面3个。
第一种情况：大 小 中，这样只会将小出栈。
我们来算一下：
大小放一块：大 * 小 + 大 * 中
小中放一块：小 * 中 + 大 * 中
所以把小和中放在一起得到的值更小。
第二种情况： 中 小 大， 小 中 都会出栈
中小放在一块：中 * 小 + 中 * 大
小大放在一块：小 * 大 + 中 * 大
因此把中小放在一起得到的值更小。
由此得出结论如果遇到出栈情况，我们将小的那个(也就是栈顶元素)和它左边或右边较小的那个放在一起得到的答案是最优。
同时，小的那个元素就不再需要了，我们只看大的那个元素可能还会和别的值相乘。
最后将值放入栈后，栈内元素单调递减，于是就有了大 中 小,这个可以自己去证。会发现还是把中小放在一起最优。

*/



//dp  O(N^3)
class Solution {
public:
    int mctFromLeafValues(vector<int>& arr) {
        
        if(arr.size() == 0)
            return 0;

        int arr_len = arr.size();

        vector<vector<int> > dp_max(arr_len+1, vector<int>(arr_len,0));
        vector<vector<int> > dp_sum(arr_len+1, vector<int>(arr_len,0));

        for(int i =0;i<arr_len;++i){
            dp_max[1][i] = arr[i];
        }

        for(int len = 2;len <= arr_len; ++len){
            for(int i = 0;i<=arr_len-len;++i){
                int j = i + len - 1;

                dp_sum[len][i] = dp_max[1][i] * dp_max[len-1][i+1] + dp_sum[1][i] + dp_sum[len-1][i+1];
                dp_max[len][i] = max(dp_max[1][i] , dp_max[len-1][i+1]);
                for(int k =i+1; k<j;++k){
                    int temp = dp_max[k-i+1][i] * dp_max[j-k][k+1] + dp_sum[k-i+1][i]+ dp_sum[j-k][k+1];
                    if(temp < dp_sum[len][i]){
                        dp_sum[len][i] = temp;
                        dp_max[len][i] = max(dp_max[k-i+1][i] , dp_max[j-k][k+1]);
                    }
                    
                }

            }
        }

        return dp_sum[arr_len][0];

    }
};


